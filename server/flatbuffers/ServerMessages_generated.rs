// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use crate::Chat_generated::*;
use crate::GameState_generated::*;
use crate::Game_generated::*;
use crate::Math_generated::*;
use crate::Player_generated::*;
use crate::User_generated::*;
use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod server_messages {

    use crate::Chat_generated::*;
    use crate::GameState_generated::*;
    use crate::Game_generated::*;
    use crate::Math_generated::*;
    use crate::Player_generated::*;
    use crate::User_generated::*;
    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_RESPONSE_CODE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_RESPONSE_CODE: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_RESPONSE_CODE: [ResponseCode; 2] =
        [ResponseCode::OK, ResponseCode::ERROR];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ResponseCode(pub i8);
    #[allow(non_upper_case_globals)]
    impl ResponseCode {
        pub const OK: Self = Self(0);
        pub const ERROR: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::OK, Self::ERROR];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::OK => Some("OK"),
                Self::ERROR => Some("ERROR"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ResponseCode {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ResponseCode {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ResponseCode {
        type Output = ResponseCode;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ResponseCode {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ResponseCode {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ResponseCode {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SERVER_MESSAGE_PAYLOAD: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SERVER_MESSAGE_PAYLOAD: u8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SERVER_MESSAGE_PAYLOAD: [ServerMessagePayload; 4] = [
        ServerMessagePayload::NONE,
        ServerMessagePayload::JoinResponsePayload,
        ServerMessagePayload::LeaveResponsePayload,
        ServerMessagePayload::StatePayload,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ServerMessagePayload(pub u8);
    #[allow(non_upper_case_globals)]
    impl ServerMessagePayload {
        pub const NONE: Self = Self(0);
        pub const JoinResponsePayload: Self = Self(1);
        pub const LeaveResponsePayload: Self = Self(2);
        pub const StatePayload: Self = Self(3);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::JoinResponsePayload,
            Self::LeaveResponsePayload,
            Self::StatePayload,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::JoinResponsePayload => Some("JoinResponsePayload"),
                Self::LeaveResponsePayload => Some("LeaveResponsePayload"),
                Self::StatePayload => Some("StatePayload"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ServerMessagePayload {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ServerMessagePayload {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ServerMessagePayload {
        type Output = ServerMessagePayload;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ServerMessagePayload {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ServerMessagePayload {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ServerMessagePayload {}
    pub struct ServerMessagePayloadUnionTableOffset {}

    pub enum JoinResponsePayloadOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct JoinResponsePayload<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for JoinResponsePayload<'a> {
        type Inner = JoinResponsePayload<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> JoinResponsePayload<'a> {
        pub const VT_CODE: flatbuffers::VOffsetT = 4;
        pub const VT_GAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            JoinResponsePayload { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args JoinResponsePayloadArgs<'args>,
        ) -> flatbuffers::WIPOffset<JoinResponsePayload<'bldr>> {
            let mut builder = JoinResponsePayloadBuilder::new(_fbb);
            if let Some(x) = args.game {
                builder.add_game(x);
            }
            builder.add_code(args.code);
            builder.finish()
        }

        #[inline]
        pub fn code(&self) -> ResponseCode {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ResponseCode>(JoinResponsePayload::VT_CODE, Some(ResponseCode::OK))
                    .unwrap()
            }
        }
        #[inline]
        pub fn game(&self) -> Option<super::game::Game<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::game::Game>>(
                        JoinResponsePayload::VT_GAME,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for JoinResponsePayload<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ResponseCode>("code", Self::VT_CODE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::game::Game>>(
                    "game",
                    Self::VT_GAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct JoinResponsePayloadArgs<'a> {
        pub code: ResponseCode,
        pub game: Option<flatbuffers::WIPOffset<super::game::Game<'a>>>,
    }
    impl<'a> Default for JoinResponsePayloadArgs<'a> {
        #[inline]
        fn default() -> Self {
            JoinResponsePayloadArgs {
                code: ResponseCode::OK,
                game: None,
            }
        }
    }

    pub struct JoinResponsePayloadBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> JoinResponsePayloadBuilder<'a, 'b> {
        #[inline]
        pub fn add_code(&mut self, code: ResponseCode) {
            self.fbb_.push_slot::<ResponseCode>(
                JoinResponsePayload::VT_CODE,
                code,
                ResponseCode::OK,
            );
        }
        #[inline]
        pub fn add_game(&mut self, game: flatbuffers::WIPOffset<super::game::Game<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::game::Game>>(
                    JoinResponsePayload::VT_GAME,
                    game,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> JoinResponsePayloadBuilder<'a, 'b> {
            let start = _fbb.start_table();
            JoinResponsePayloadBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<JoinResponsePayload<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for JoinResponsePayload<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("JoinResponsePayload");
            ds.field("code", &self.code());
            ds.field("game", &self.game());
            ds.finish()
        }
    }
    pub enum LeaveResponsePayloadOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LeaveResponsePayload<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LeaveResponsePayload<'a> {
        type Inner = LeaveResponsePayload<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LeaveResponsePayload<'a> {
        pub const VT_CODE: flatbuffers::VOffsetT = 4;
        pub const VT_GAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LeaveResponsePayload { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LeaveResponsePayloadArgs<'args>,
        ) -> flatbuffers::WIPOffset<LeaveResponsePayload<'bldr>> {
            let mut builder = LeaveResponsePayloadBuilder::new(_fbb);
            if let Some(x) = args.game {
                builder.add_game(x);
            }
            builder.add_code(args.code);
            builder.finish()
        }

        #[inline]
        pub fn code(&self) -> ResponseCode {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ResponseCode>(LeaveResponsePayload::VT_CODE, Some(ResponseCode::OK))
                    .unwrap()
            }
        }
        #[inline]
        pub fn game(&self) -> Option<super::game::Game<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::game::Game>>(
                        LeaveResponsePayload::VT_GAME,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for LeaveResponsePayload<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ResponseCode>("code", Self::VT_CODE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::game::Game>>(
                    "game",
                    Self::VT_GAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct LeaveResponsePayloadArgs<'a> {
        pub code: ResponseCode,
        pub game: Option<flatbuffers::WIPOffset<super::game::Game<'a>>>,
    }
    impl<'a> Default for LeaveResponsePayloadArgs<'a> {
        #[inline]
        fn default() -> Self {
            LeaveResponsePayloadArgs {
                code: ResponseCode::OK,
                game: None,
            }
        }
    }

    pub struct LeaveResponsePayloadBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LeaveResponsePayloadBuilder<'a, 'b> {
        #[inline]
        pub fn add_code(&mut self, code: ResponseCode) {
            self.fbb_.push_slot::<ResponseCode>(
                LeaveResponsePayload::VT_CODE,
                code,
                ResponseCode::OK,
            );
        }
        #[inline]
        pub fn add_game(&mut self, game: flatbuffers::WIPOffset<super::game::Game<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::game::Game>>(
                    LeaveResponsePayload::VT_GAME,
                    game,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LeaveResponsePayloadBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LeaveResponsePayloadBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LeaveResponsePayload<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LeaveResponsePayload<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LeaveResponsePayload");
            ds.field("code", &self.code());
            ds.field("game", &self.game());
            ds.finish()
        }
    }
    pub enum StatePayloadOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StatePayload<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StatePayload<'a> {
        type Inner = StatePayload<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> StatePayload<'a> {
        pub const VT_CODE: flatbuffers::VOffsetT = 4;
        pub const VT_GAME_STATE: flatbuffers::VOffsetT = 6;
        pub const VT_CHAT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StatePayload { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StatePayloadArgs<'args>,
        ) -> flatbuffers::WIPOffset<StatePayload<'bldr>> {
            let mut builder = StatePayloadBuilder::new(_fbb);
            if let Some(x) = args.chat {
                builder.add_chat(x);
            }
            if let Some(x) = args.game_state {
                builder.add_game_state(x);
            }
            builder.add_code(args.code);
            builder.finish()
        }

        #[inline]
        pub fn code(&self) -> ResponseCode {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ResponseCode>(StatePayload::VT_CODE, Some(ResponseCode::OK))
                    .unwrap()
            }
        }
        #[inline]
        pub fn game_state(&self) -> Option<super::game_state::GameState<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<super::game_state::GameState>>(
                        StatePayload::VT_GAME_STATE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn chat(
            &self,
        ) -> Option<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::chat::ChatMessage<'a>>>,
        > {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::chat::ChatMessage>>,
                >>(StatePayload::VT_CHAT, None)
            }
        }
    }

    impl flatbuffers::Verifiable for StatePayload<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ResponseCode>("code", Self::VT_CODE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<super::game_state::GameState>>(
                    "game_state",
                    Self::VT_GAME_STATE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::chat::ChatMessage>>,
                >>("chat", Self::VT_CHAT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StatePayloadArgs<'a> {
        pub code: ResponseCode,
        pub game_state: Option<flatbuffers::WIPOffset<super::game_state::GameState<'a>>>,
        pub chat: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::chat::ChatMessage<'a>>>,
            >,
        >,
    }
    impl<'a> Default for StatePayloadArgs<'a> {
        #[inline]
        fn default() -> Self {
            StatePayloadArgs {
                code: ResponseCode::OK,
                game_state: None,
                chat: None,
            }
        }
    }

    pub struct StatePayloadBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StatePayloadBuilder<'a, 'b> {
        #[inline]
        pub fn add_code(&mut self, code: ResponseCode) {
            self.fbb_
                .push_slot::<ResponseCode>(StatePayload::VT_CODE, code, ResponseCode::OK);
        }
        #[inline]
        pub fn add_game_state(
            &mut self,
            game_state: flatbuffers::WIPOffset<super::game_state::GameState<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<super::game_state::GameState>>(
                    StatePayload::VT_GAME_STATE,
                    game_state,
                );
        }
        #[inline]
        pub fn add_chat(
            &mut self,
            chat: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<super::chat::ChatMessage<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StatePayload::VT_CHAT, chat);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StatePayloadBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StatePayloadBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StatePayload<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for StatePayload<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("StatePayload");
            ds.field("code", &self.code());
            ds.field("game_state", &self.game_state());
            ds.field("chat", &self.chat());
            ds.finish()
        }
    }
    pub enum ServerMessageOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ServerMessage<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ServerMessage<'a> {
        type Inner = ServerMessage<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ServerMessage<'a> {
        pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 4;
        pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ServerMessage { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ServerMessageArgs,
        ) -> flatbuffers::WIPOffset<ServerMessage<'bldr>> {
            let mut builder = ServerMessageBuilder::new(_fbb);
            builder.add_timestamp(args.timestamp);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            builder.add_payload_type(args.payload_type);
            builder.finish()
        }

        #[inline]
        pub fn timestamp(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u64>(ServerMessage::VT_TIMESTAMP, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn payload_type(&self) -> ServerMessagePayload {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ServerMessagePayload>(
                        ServerMessage::VT_PAYLOAD_TYPE,
                        Some(ServerMessagePayload::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        ServerMessage::VT_PAYLOAD,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_join_response_payload(&self) -> Option<JoinResponsePayload<'a>> {
            if self.payload_type() == ServerMessagePayload::JoinResponsePayload {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { JoinResponsePayload::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_leave_response_payload(&self) -> Option<LeaveResponsePayload<'a>> {
            if self.payload_type() == ServerMessagePayload::LeaveResponsePayload {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LeaveResponsePayload::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn payload_as_state_payload(&self) -> Option<StatePayload<'a>> {
            if self.payload_type() == ServerMessagePayload::StatePayload {
                self.payload().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { StatePayload::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ServerMessage<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_union::<ServerMessagePayload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          ServerMessagePayload::JoinResponsePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<JoinResponsePayload>>("ServerMessagePayload::JoinResponsePayload", pos),
          ServerMessagePayload::LeaveResponsePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeaveResponsePayload>>("ServerMessagePayload::LeaveResponsePayload", pos),
          ServerMessagePayload::StatePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StatePayload>>("ServerMessagePayload::StatePayload", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ServerMessageArgs {
        pub timestamp: u64,
        pub payload_type: ServerMessagePayload,
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ServerMessageArgs {
        #[inline]
        fn default() -> Self {
            ServerMessageArgs {
                timestamp: 0,
                payload_type: ServerMessagePayload::NONE,
                payload: None,
            }
        }
    }

    pub struct ServerMessageBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ServerMessageBuilder<'a, 'b> {
        #[inline]
        pub fn add_timestamp(&mut self, timestamp: u64) {
            self.fbb_
                .push_slot::<u64>(ServerMessage::VT_TIMESTAMP, timestamp, 0);
        }
        #[inline]
        pub fn add_payload_type(&mut self, payload_type: ServerMessagePayload) {
            self.fbb_.push_slot::<ServerMessagePayload>(
                ServerMessage::VT_PAYLOAD_TYPE,
                payload_type,
                ServerMessagePayload::NONE,
            );
        }
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ServerMessage::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ServerMessageBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ServerMessageBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ServerMessage<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ServerMessage<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ServerMessage");
            ds.field("timestamp", &self.timestamp());
            ds.field("payload_type", &self.payload_type());
            match self.payload_type() {
                ServerMessagePayload::JoinResponsePayload => {
                    if let Some(x) = self.payload_as_join_response_payload() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ServerMessagePayload::LeaveResponsePayload => {
                    if let Some(x) = self.payload_as_leave_response_payload() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ServerMessagePayload::StatePayload => {
                    if let Some(x) = self.payload_as_state_payload() {
                        ds.field("payload", &x)
                    } else {
                        ds.field(
                            "payload",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("payload", &x)
                }
            };
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `ServerMessage`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_server_message_unchecked`.
    pub fn root_as_server_message(
        buf: &[u8],
    ) -> Result<ServerMessage, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<ServerMessage>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `ServerMessage` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_server_message_unchecked`.
    pub fn size_prefixed_root_as_server_message(
        buf: &[u8],
    ) -> Result<ServerMessage, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<ServerMessage>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `ServerMessage` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_server_message_unchecked`.
    pub fn root_as_server_message_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<ServerMessage<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<ServerMessage<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `ServerMessage` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_server_message_unchecked`.
    pub fn size_prefixed_root_as_server_message_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<ServerMessage<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<ServerMessage<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a ServerMessage and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `ServerMessage`.
    pub unsafe fn root_as_server_message_unchecked(buf: &[u8]) -> ServerMessage {
        flatbuffers::root_unchecked::<ServerMessage>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed ServerMessage and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `ServerMessage`.
    pub unsafe fn size_prefixed_root_as_server_message_unchecked(buf: &[u8]) -> ServerMessage {
        flatbuffers::size_prefixed_root_unchecked::<ServerMessage>(buf)
    }
    #[inline]
    pub fn finish_server_message_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<ServerMessage<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_server_message_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<ServerMessage<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod ServerMessages
